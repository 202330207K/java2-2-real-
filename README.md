# 김재화 202330207

# 4월 19일

# 메소드 오버라이딩의 개념

* 메소드 오버라이딩
    * 서브 클래스에서 슈퍼클래스의 메소드 중복 작성
    * 슈퍼 클래스의 메소드 무력화, 항상 서브클래스에 오버라이딩한 메소드가 실행 되도록 보장됨

# 오버라이딩의 목적, 다형성 실현

* 오버라이딩의 목적, 다형성 실현
    * 하나의 인터페이스에서 다른 구현


* 동적 바인딩 - 오버라이딩 된 메소드르 호출

# 추상 클래스

* 추상 메소드
    * 온전한 클래스가 아니기 때문에 인스턴스를 생성 할수 없음

* 추상 클래스 상속
    * 추상 클래스를 상속 받으면 추상 클래스가 됨
    * 서브 클래스도 abstract 로 선언 해야한다.

* 추상 클래스 구현  
    * 서브 클래스에서 슈퍼 클래스ㅇ의 추상 메소드 구현(오버라이딩)
    * 추상 클래스를 구현한 서브 클래스는 추상 클래스가 아니다.

# 인터페이스의 필요성 
* 자바의 인터페이스
    * 클래스가 구현해야할 메소드들이 선언되는 추상형
    * 인터페이스 선언 
        * interface 키워드로 선언
        * ex) public interface SeriaDriver (~)
* 자바 인터페이스에 대한 변화
    * java7 까지
        * 인터페이스는 상수와 추상 메소드로만 구성
    * java8 부터 
        * 상수와 추상 메소드 포함
        * default 메소드 포함
        * private 메소드 포함
        * static 메소드 포함


# 박싱과 언박싱
* 박싱 
    * 기본타입의 값을 Wapper 객체로 변환하는것

* 스트링 리터럴 과 new String()
* 스트링 리터럴
    * 자바 가상 기계 내부에서 리터럴 테이블에 저장되고 관리됨
    * 응용프로그램에서 공유됨





# 4월 12일

# 클래스 접근 지정

* 클래스 접근 지정
    * 다른클래스에서 사용하도록 허용할 지  지정
    * public 클래스
    * 디폴트 클래스   
* 맴버 접근 지정
    * public 멤버 
        * 패키지에 관계없이 모든 클래스에게 접근 허용
    * private 멤버
        * 동일클래스 내에만 접근 허용
        * 상속받은 서브 클래스에서 접근 불가

* static 멤버 
    * static 멤버 선언
        * 교과서 p.172 참조
    * 객체 생성과 non-static 멤버의 생성
        * non-static 멤버는 객체가 생성될 때, 객체마다 생긴다.
    * static 멤버는 클래스당 하나만 생성 
    * 객체들에 의해 공유됨
    * non-static 과 static 차이
        * 교과서 p.174 참조
    
    * static 멤버 사용
        * 클래스 이름으로 접근 가능
        * 객체의 멤버로 접근 가능
        * non-static 멤버는 클래스 이름으로 접근 안됨

* static 메소드의 제약 조건 1
    * static 메소드는 오직 static 멤버만 접근 가능
        * 객체가 생성되지 않은 상황에서도 static 메소드는 실행될 수 있기 때문에 non-static 멤버 활용 불가
        * non-static 메소드는 static 멤버 사용 가능 

* static 메소드의 제약 조건 2
    * static 메소드는 this 사용 불가 
        * static  메소드는 객체 없이도 사용 가능하므로, this 래퍼런스 사용할 수 없음

# final 클래스와 메소드
* final 클래스 - 더이상 클래스 불가능
* final 메소드 - 더이상 오버라이딩 불가능

* final 필드    
    * final 필드, 상수 선언
        * 상수를 선언할 때 사용
        * 상수 필드는 선언 시에 초기 값을 지정하여야 한다
        * 상수 필드는 실행 중에 값을 변경할 수 없다


## 상속

# 상속의 필요성(p.191 그림 5-2,3)

# 클래스 상속과 객체
* 상속 선언
    * extends 키워드로 선언
        * 부모 클래스를 물려받아 확장한다는 의미
    * 부모 클래스 > 슈퍼 클래스
    * 자식 클래스 > 서브 클래스

# 자바 상속의 특징
* 클래스 다중 상속 불허
    * c++ 은 다중 상속 가능
    


# 4월 5일

# 메소드의 배열 리턴
* 배열 리턴
    * 배열의 래퍼런스만 리턴(배열 전체가 리턴되는 것이 아님)
* 메소드의 리턴 타입
    * 리턴하는 배열타입과 리턴받는 배열타입 일치
    * 리턴 타입에 배열의 크기를 지정하지 않음
```java
int [] makeArray() { // 리턴타입 , 메소드 이름
    int temp[] = new int[4]; 
    return temp; // 배열 리턴
}
```

* 배열을 리턴받아 사용하는 과정
    * 교과서 p.113 그림 3-16 참조

# 자바의 예외 처리
* 예외(Exception)
    * 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생
        * 자바에서는 실행중 발생하는 에러를 예외를 처리
    * 예외 발생 경우
        * 정수를 0으로 나누는 경우 
        * 배열의 크기보다 큰 인덱스로 배열의 원소를 접근하는 경우
        * 정수를  읽는 코드가 실행되고 있을 때 사용자가 문자를 입력한 경우

* try-catch-finally 문
    * 예외 처리 
        * 발생한 예외에 대해 가발자가 작성한  프로그램 내에서 대응하는 것
        * 사용법 교과서 p.116 참조

* 예외 클래스 사례 
    * 배열의 범위를 벗어나 원소를 접근하는 예외 처리
        * ArrayIndexOutOfBoudndsException
    * 이외의 경우 교과서 p.117 표 3-1 참조

# 자바의 객체지향 특성

# 캡슐화 
* 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
    * 객체의 가장 본질적인 특징
        * 외부의 접근으로부터 객체 보호
* 자바의 캡슐화 
    * 클래스 객체 모양을 선언한 틀(캡슐화하는 틀)
    * 클래스 모양 그대로 생성된 실체가 객체
# 상속
* 상위 개체의 속성이 하위 개체에 물려짐
* 하위 개체가 상위개체의 속성을 모두 가지는 관계

* 자바의 상속
    * 상위 클래스의 맴버를 하위 클래스가 물려받음
        * 상위 클래스 : 수퍼 클래스
        * 하위 클래스 : 서브 클래스, 수퍼 클래스 코드의 재사용, 새로운 특성 추가 가능

# 다형성 
* 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
* 다형성 사례
    * 메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
    * 메소드 오버라이딩 : 슈퍼클 래스의 메소드를 동일한 이름으로 서브 클래스 마다 다르게 구현

# 객체 지향 언어의 목적

1. 소프트웨어의 생산성 향상
    * 컴퓨터 산업 발전에 따라 소프트웨어의 생명주기 (life cycle) 단축
        * 소프트웨어를 빠른 속도로 생산할 필요성 중대
    * 객체 지향 언어
        * 상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
        * 소프트웨어 재사용과 부분 수정 빠름
        * 소프트웨어를 다시 만드는 부담 대폭 줄임
        * 소프트웨어 생산성 향상
0
2. 실세계에 대한 쉬운 모델링
    * 과거에는 통계 처리등 데이터의 처리절차가 중요했지만
        * 이제는 실세계에서 발생하는 일을 프로그래밍 해야하는 경우가 많아짐
        * 그래서 더 쉬운 객체지향 언어가 필요하게 됨

# 클래스와 객체
* 클래스 
    * 객체의 속성과 행위 선언
    * 객체의 설계도 혹은 틀
* 객체 
    * 클래스의 틀로 찍어낸 실체
        * 프로그램 실행중에 생성되는 객체

# 자바클래스 구성
* 클래스 
    * class 키워드로 선언
    * 멤버 : 클래스 구성 요소
        * 필드(멤버 변수) 와 메소드(멤버 함수)
    * 클래스에 대한 public 접근 지정 : 다른 모든 클래스에서 클래스 사용 허락
    * 멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용

* 객체 맴버 접근 
    * 교과서 p.142 참조

# 생성자의 특징 
* 생성자 이름 은 클래스 이름과 동일
* 생성자는 여러 개 작성 가능(생성자 중복)
* 생성자는 객체 생성시 한 번만 호출 
    * 자바에서 객체 생성은 반드시 new 연산자로 함
* 생상자의 목적은 객체 생성 시 초기화
* 생성자는 리턴 타입을 지정 할 수 없음

# this() 레퍼런스
* this()
    * 객체 자신에 대한 레퍼런스로 메소드 안에서 사용된다
        * 컴파일러에 의해 자동으로 관리되므로, 개발자는 사용만 하면된다
    * 객체가 있어야 this도 의미가 있다.

* this로 다른 생성자 호출
    * 클래스 내에서 생성자가 다른 생성자르 호출할 때 사용하는 자바코드

# 객체배열

* 자바의 객체 배열
    * 객체에 대한 레퍼런스 배열임
* 자바의 객체배열 만들기 3단계
    1. 배열 레퍼런스 변수 선언
    2. 레퍼런스 배열 생성
    3. 배열의 각 원소 객체 생성

# 메소드 
* 메소드
    * 메소드는 c/c++ 의 함수와 동일
    * 자바의 모든 메소드는 반드시 클래스 안에 있어야 함 (캡슐화 원칙)

    * 메소드 형식 p.157 그림 4-18 참조

* 메소드 오버로딩
    * 오버로딩
        * 한 클래스 내에서 두 개 이상의 이름 이 같은 메소드 작성
            * 메소드 이름이 동일 하여야 함
            * 매개 변수가 개수가 서로 다르거나 타입이 달라야 함
            * 리턴타입과 접근 지정자는 메소드 오버로딩과 관계없다.
    * 오버로딩 성공/실패 사례
        * p.162 참조

# 객체 치환시 주의할 점
* 객체 치환은 객체 복사가 아니며, 레퍼런스의 복사이다

# 객체 소멸
* 객체 소멸
    * new 에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려주는 행위
    * 소멸된 객체 공간은 가용 메모리에 포함
* 자바에서 사용자 임의로 객체 소멸 안됨
    * 자바는 객체 소멸 연산자 없음 
        * 객체 생성 연산자 : new
    * 객체 소멸은 자바 가상 기계의 고유한 역할
    * 자바 개발자에게는 매우 다행스러운 기능
        * c/c++ 에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야함
        * c/c++ 의 프로그램 작성을 어렵게 만드는 요인
        * 자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방

# 가비지
* 가비지
    * 가리키는 레퍼런스가 하나도 없는 객체
* 가비지 컬렉션 
    * 자바 가상기계의 가비지 컬렉터가 자동으로 가비지 수집, 반환
        * 가용 메모리 공간이 일정 이하로 부족해질 때
        * 가비지를 수거하여 가용 메모리 공간으로 확보
    * 가비지 컬렉터에 의해 자동 수행
* 강제 가비지 컬렉션 강제수행




# 3월 29일

# 변수와 선언
* 변수
    * 프로그램 실행중에 값을 임시 저장하기 위한 공간 (변하는 데이터)
* 변수 선언 
    * 데이터 타입 크기에 맞는 메모리 공간이 할당됨

# 리터럴과 정수 리터럴
* 리터럴(lliteral)
    * 프로그램에서 직접 표현한 값
    * 정수, 실수, 문자, 논리, 문자열 리터럴 있음
* 정수 리터럴
    * 10진수, 8진수, 16진수, 2진수 리터럴
    * 정수 리터럴은 int 형으로 컴파일
    * long 타입 리터럴은 숫자 뒤에 L 또는 l 을 붙여 표시

# 실수 리터럴 
* 소수점 형태나 지수 형태로 표현한 실수
* 실수 타입 리터럴은 double 타입으로 컴파일

# 문자 리터럴
* 단일 인용부호(' ') 로 문자 표현
* 특수문자 리터럴은 백슬래쉬(\) 로 시작

# 기본 타입 이외 리터럴
* null 리터럴 
    * 래퍼런스에 대입 사용

* 문자열 리터럴(스트링 리터럴)
    * 이중 인용부호로 묶어 표현
    * 문자 리터럴은 String 객체로자동 처리
    
    ```java
    String str = "Good";
    ```

# 상수
* 상수 선언 
    * final 키워드 사용
    * 선언 시 초깃값 지정
    * 실행 중 값 변경 불가

# var 키워드
* Java 10 부터 도입
* 기존의 변수 선언 방식 : 변수의 타입 반드시 지정
* var 키워드
    * 타입을 생략하고 변수 선언 가능
    * 컴파일러가 추론하여 변수 타입 결정
    * 변수 선언 시 초깃값이 주어지지 않으면 컴파일 오류가 난다
    ```java
    var name; // 컴파일 오류
    ```
    * var 는 지역 변수 선언에만 한정

# 타입 변환
* 타입 변환
    * 한 타입의 값을 다른 타입의 값으로 변환
* 강제 타입 변환
    * 개발자의 의도적 타입 변환
    * () 안에 개발자가 명시적으로 타입 변환 지정
    ```java
    int n = 300;
    byte b = n; // 컴파일 오류 int 타입은 byte 타입으로 자동 변환 안 됨
    ```
    
    * 강제 변환은 값 손실 우려

# 자바의 키 입력과 System.in
* System.in
    * 키보드와 직접 연결되는 표준 입력 스트림 객체

# Scanner
* Scanner 클래스
    * 읽은 바이트를 문자나 정수, 실수, 문자열 등 다양한 타입으로 변환하여 리턴
    * 객체 생성
    ```java
    Scanner scanner = new Scanner(System.in);
    ```
    

    ```java
    import java.util.Scanner;
    ```
    
* 주요 메소드 교과서 
    * P. 64 참조

# 식과 연산자 
* 연산 
    * 주어진 식을 계산하여 결과를 얻어내는 과정
* 산술 연산
    * 더하기(+) 빼기 (-) 곱하기 (*) 나누기 (/) 나머지 (%)

# 증감 연산
* 1 증가 혹은 감소 시키는 연산 
    a++ > a 를 1 증가하고 증가 전의 값 변환
    ++a > a 를 1 증가하고 증가된 값 반환
    a-- > a 를 1 감소하고 감소 전의 값 변환
    --a > a 를 1 감소하고 감소된 값 변환
* 대입연산자 
    * 교과서 p.69 참고
# 비교 연산, 논리 연산
* 비교연산자 : 두 개의 값을 비교하여 true/false 결과
* 논리연산자 : 두 개의 논리 값에 논리 연산, 논리 결과
    * 교과서 p.70 참고

# 비트 연산
* 비트 개념 
    * p.72 그림 2-8 참고
* 비트 논리 연산
    * 피 연산자의 각 비트들을 대상으로 하는 연산
    * p.72 그림 2-9 참고
* 시프트 연산도 p.73 2-10 표, 그림 참고

# if else 문
* 단순 if 문 
    * if 의 괄호 안에 조건식 
    * 괄호 안에 조건이 참이면 if 실행 아니면 else 실행

* 다중 if 문
    * 조건문이 너무너무 많을 경우 switch 문 활용 권장 
    * 교과서 p.77~78 참고

* 중첩 if 문 
    * if 문이나 else문, 혹은 if-else 문에 if 문이나 if-else 문을 내포 할 수 있다.

# switch 문
* switch 문은 식과 case 문의 값과 비교 
    * case의 비교 값과 일치하면 해당 case의 실행문장 수행
        * break 문 만나면 switch 문을 벗어남
    * case의 비교 값과 일치하는 것이 없으면 default 문 실행 (생략 가능)

* case 문의 값 
    * 문자, 정수, 문자열 리터럴(JDK 1.7부터) 만 허용
    * 실수 래터럴은 허용되지 않음

# 반복문
* for 문
    * 교과서 p.92~93 그림 참고

* while 문
    * 교과서 p.94~95 그림 참고
 
# 가비지 컬렉션
* ex) scanner 쓰고 마지막에 scanner.close() 를 쓰지 않으면 메모리를 잡아먹는다.

# 중첩 반복문 
* 중첩 반복
    * 반복문이 다른 반복문을 내포하는 구조

# continue 문
* 반복문을 빠져나가지 않으면서 즉시 다음 반복으로 넘어가고자 할 때 사용
```java
continue;
```

# 자바 배열
* 배열 (array)
    * 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료구조
        * 배열을 이용하면 한 번에 많은 메모리 공간 선언 가능
    
* 배열 선언 및 생성 
    * 배열에 대한 레퍼런스 변수 선언 
    ```java
    int intArray [];
    ```
    * 배열 생성
    ```java
    intArray = new int [5];
    ```
* 배열 초기화
    ```java
    int intArray[] = {4,3,2,1,0};
    double doubleArray[] = {0.01, 0.02, 0.03, 0.04};
    ```
    * 이때 배열의 크기는 자동으로 5 와 4 가 된다.

* 배열 인덱스
    * 배열의 인덱스는 0 ~ (배열 크기 -1)
    ```java
    int intArray = new int[5]; // 인덱스는 0~4
    intArray[0] = 5;           // 원소 0 에 5 저장
    intArray[3] = 5;           // 원소 3에 6 저장
    int n = intArray[3];       // 원소 3의 값을 읽어 n 에 저장. n은 6이 됨
    ```
 # 레퍼런스 치환과 배열 공유
 * 레퍼런스 치환으로 두 레퍼런스가 하나의 배열 공유
    * 교과서 p.105 그림 3-11 참고





## 3월 22일

# 프로그래밍 언어
우리가 하고 있는 언어는 고급 언어  

# 컴파일(.exe)
소스 파일을 컴퓨터가 이해할 수 있는 기계어로 만드는 과정  
* 자바 : .java > .class

# 기존언어의 플랫폼 종속성 
플랫폼 = 하드웨어 플랫폼 + 운영체제 플랫폼  

프로그램의 플랫폼 호환성이 없는 이유
* 기계어가 CPU마다 다름  
* 운영체제마다 API가 다름  
* 운영체제마다 실행 파일 형식이 다름 

# 자바 플랫폼 독립성 WORA
* WORA(Write Once Run Anyware)
    * 한 번 작성된 코드는 모든 플랫폼에서 바로 실행되는 자바의 특징
    * C/C++ 등 기존 언어가 가진 플랫폼 종속성 극복
        - OS H/S에 상관 없이 자바프로그램이 동일하게 실행 
    * 네트워크에 연결된 어느 클라이언트에서나 실행 
        - 웹 브라우저, 분산 환경 지원

 # 자바 API
 * JDK 에 포함된 클래스 라이브러리
 * 개발자는 API를 이용하여 쉽고 빠르게 자바 프로그램 개발

 # 자바 패키지
 * 서로 관련된 클래스들을 분류하여 묶어놓은 것
 * 계층구조로 되어있음
 * 자바 API(클래스 라이브러리) 는 JDK에 패키지 형태로 제공됨
 * 개발자 자신의 패키지 생성 가능

 # 자바 프로그램 개발 : (1) 자바 소스 편집
 * 어떤 편집기를 사용해도 무관  
    작성 후 클래스와 동일한 이름으로 저장 후 확장자는 .java

# 자바 응용의 종류 : 서블릿 응용 프로그램
* 서블릿
    * 웹 서버에서 실행되는 자바 프로그램
    * 데이터베이스 서버 및 기타 서버와 연동하는 복잡한 기능 구현 시 사용
    * 웹 서버에 의해 실행 통제 받음 

# 자바의 특성 (1)
 * 플랫폼 독립성
    * 하드웨어, 운영체제에 종속되지 않는 바이트 코드로 플랫폼 독립성을 갖는다
 * 객체지향
    * 캡슐화, 상속, 다향성 지원
 * 클래스로 캡슐화 
    * 자바의 모든 변수나 함수는 클래스 내에 선언
    * 클래스 안에서 클래스(내부 클래스) 작성 가능
 * 소스와 클래스 파일
    * 하나의 소스파일에 여러 클래스를 작성 가능
    * 소스 파일의 이름과 public 으로 선언된 클래스 이름은 같아야 한다
    * 클래스 파일에는 하나의 클래스만 존재

# 자바의 특성 (2)
* 실행 코드 배포
    * 구성
        - 한 개의 class 파일 또는 다수의 class 파일로 구성
        - 여러 폴더에 걸쳐 다수의 클래스 파일로 구성된 경우 : jar 압축 파일로 배포
    * 자바 응용프로그램의 실행은 main() 메소드에서 시작
* 패키지
    * 서로 관련 있는 여러 클래스를 패키지로 묶어 관리
    * 패키지는 폴더 개념
* 멀티스레드
    * 여러 스레드의 동시 수행 환경 지원
        - 자바는 운영체제의 도움없이 자체적으로 멀티스레드 지원
        - C/C++ 프로그램은 멀티스레드를 위해 운영체제 API를 호출
* 가비지 컬렉션
    * 자바 언어는 메모리 할당 기능은 있어도 메모리 반환 기능 없음
        - 사용하지 않는 메모리는 자바 가상 기계에 의해 자동 변환 - 가비지 컬렉션

# 자바의 특성 (3)
* 실시간 응용프로그램에 부적합 
     * 실행 도중 예측할 수 없는 시점에 가비지 컬렉션 실행 때문
        - 응용프로그램의 일시적 중단 발생
* 자바 프로그램은 안전
    * 타입 체크 엄격
    * 물리적 주소를 사용하는 포인터 개념 없음
* 프로그램 작성 쉬움
    * 포인터 개념이 없음 
    * 동적 메모리 변환 하지않음
    * 다양한 라이브러리 지원
* 실행속도 개선을 위한 JIT 컴파일러 사용
    * 자바는 바이트 코드를 인터프린터 방식으로 실행
        - 기계어가 실행되는 것보다 느림
    * JIT 컴파일 기법으로 실행 속도 개선
        - JIT 컴파일 - 실행 중에 바이트 코드를 기계어 코드로 컴파일하여 기계어를 실행하는 기법

# 식별자
* 클래스, 변수, 상수, 메소드 등에 붙이는 이름
* 식별자의 원칙 
    [참고링크](https://www.cubrid.org/manual/ko/10.2/sql/identifier.html)
* 대소문자 구별
    - int barChart 와 int barchart 는 서로 다른 식별자 선언

# 자바의 기본 타입
* 특징 타입마다 크기가 다르기 때문에  
 다루는 값에 범위에 따라 적절한 타입을 선택하여야

# 문자열 특징 
* 기본타입에 속하지 않으며 JDK 에서 제공하는 String 클래스를 이용한다.

# 변수와 선언
* 변수
    * 프로그램 실행중에 값을 임시 저장하기 위한 공간
* 변수 선언 
    * 데이터 타입 크기에 맞는 메모리 공간이 할당됨

# 리터럴과 정수 리터럴
* 리터럴(lliteral)
    * 프로그램에서 직접 표현한 값
    * 정수, 실수, 문자, 논리, 문자열 리터럴 있음
* 정수 리터럴
    * 10진수, 8진수, 16진수, 2진수 리터럴
    
## 3월 15일

# Markdown 문법
## 폰트관련 태그

# h1 
## h2
### h3
#### h4
##### h5
###### h6


일반 글씨는 그냥 작성
개행(newline)을 하려면  
스페이스 2개입력

*이탈릭체*
**굵게**
***이텔릭, 볼드***
## 리스트(list)

1. 첫 번째
2. 두 번째
3. 세 번째

* 첫 번째
   - 두 번째
      + 세 번째


## 코드 블럭

```java
public class main(String[] args){
    System.out.println("hello world!");
}
```

```python
print("hi zz")
```

## 링크 
[구글링크](https://google.com)  
[리스트](#markdown-문법)  
[리트리버](./20230111503366.jpg)  
[절대경로](https://flexible.img.hani.co.kr/flexible/normal/850/567/imgdb/original/2023/0111/20230111503366.jpg)


## 버전
[참고링크](https://semver.org/lang/ko/)
